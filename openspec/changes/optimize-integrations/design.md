# Design: Integration Enhancements (Phase 5)

## Context
This design enhances the existing reporting and agent-runtime capabilities with richer Slack notifications, advanced prompting techniques, and support for multiple agent backends. This builds on the stable Phase 1-4 foundation where the runner already handles event intake, agent invocation, and basic reporting via webhook notifications.

## Goals
- **Richer Slack Integration**: Upload full reports and artifacts as files instead of just webhook text snippets.
- **Smarter Agents**: Improve investigation quality through few-shot prompting and troubleshooting examples.
- **Backend Flexibility**: Support multiple agent backends (Claude, Aider, OpenAI-compatible endpoints) without code changes.

## Non-Goals
- Two-way Slack interactivity (buttons triggering actions) - notifications remain one-way for now.
- Real-time streaming of agent output to Slack - uploads happen after completion.
- Complex agent orchestration (multi-agent coordination) - single agent per investigation.
- Full Slack app distribution via App Directory.

## Decisions

### Decision 1: Slack Bot Token vs Webhook

**Decision**: Add optional Bot Token support while maintaining backward compatibility with webhooks.

**Rationale**:
- **Webhooks** (current): Simple, no app installation, but limited to basic text messages and cannot upload files.
- **Bot Tokens** (new): Require Slack app installation and OAuth flow, but enable file uploads, rich Block Kit messages, and thread replies.
- **Approach**: Make Bot Token opt-in via configuration. If `SLACK_BOT_TOKEN` is present, use files.upload API. If only `SLACK_WEBHOOK_URL` exists, use current webhook approach.

**Alternatives Considered**:
- Force migration to Bot Token: Rejected - too disruptive for simple use cases.
- Keep webhook-only: Rejected - prevents file uploads and richer UX.

**Implementation Notes**:
- Bot Token requires the `files:write` scope for file uploads.
- Bot Token requires `chat:write` scope for posting messages.
- Use Slack's new upload pattern: `files.getUploadURLExternal` + `files.completeUploadExternal` (the legacy `files.upload` is being deprecated November 2025).
- For thread replies, capture the `ts` (timestamp) from the initial message and pass as `thread_ts` in subsequent calls.

### Decision 2: Slack Block Kit Message Structure

**Decision**: Use Block Kit for summary messages with expandable sections for findings.

**Message Structure**:
```
[Header Block] - Incident ID and Severity
[Section Block] - Timestamp, Namespace, Resource Name
[Divider]
[Section Block] - Executive Summary (collapsed by default)
[Actions Block] - Button linking to uploaded report.md
[Context Block] - "Generated by nightcrier"
```

**Rationale**:
- Block Kit provides better visual hierarchy than plain text.
- Expandable sections keep initial message compact.
- Action buttons make navigation to detailed reports frictionless.

**File Upload Strategy**:
- Upload `report.md` as a Slack file using `files.getUploadURLExternal`.
- Upload artifact bundle (e.g., `artifacts.tar.gz`) if present.
- Link to uploaded files from the message blocks.
- Use `thread_ts` to post follow-up artifacts in the same thread.

### Decision 3: Agent Backend Abstraction

**Decision**: Create a pluggable agent backend system with a configuration-driven approach.

**Backend Configuration Schema**:
```yaml
agent:
  backend: "claude"  # or "aider", "openai-compatible"
  config:
    claude:
      command: "claude"
      args: ["--headless", "--context-file"]
      env:
        ANTHROPIC_API_KEY: "${ANTHROPIC_API_KEY}"
    aider:
      command: "aider"
      args: ["--model", "claude-3-7-sonnet", "--yes", "--no-auto-commits"]
      env:
        ANTHROPIC_API_KEY: "${ANTHROPIC_API_KEY}"
    openai-compatible:
      command: "aider"  # or custom script
      args: ["--model", "gpt-4o", "--openai-api-base"]
      env:
        OPENAI_API_KEY: "${OPENAI_API_KEY}"
        OPENAI_API_BASE: "https://api.example.com/v1"
```

**Abstraction Design**:
- Define an `AgentBackend` interface in Go:
  ```go
  type AgentBackend interface {
      Name() string
      PrepareCommand(ctx context.Context, workspaceDir string, incidentContext IncidentContext) (*exec.Cmd, error)
      ValidateConfig() error
  }
  ```
- Implement backends: `ClaudeBackend`, `AiderBackend`, `OpenAICompatibleBackend`.
- Each backend handles command construction, environment variable injection, and context file preparation.
- Configuration selects the backend at runtime.

**Alternatives Considered**:
- Hardcode each backend: Rejected - not extensible.
- Use a generic script wrapper: Rejected - loses type safety and validation.

### Decision 4: Prompt Template System

**Decision**: Implement a template-based prompt system with few-shot example injection.

**Template Structure**:
```markdown
# System Context
You are investigating a Kubernetes incident. Your goal is to diagnose the root cause using read-only tools.

## Incident Details
- Incident ID: {{.IncidentID}}
- Severity: {{.Severity}}
- Namespace: {{.Namespace}}
- Resource: {{.ResourceKind}}/{{.ResourceName}}
- Event Reason: {{.Reason}}
- Event Message: {{.Message}}

## Investigation Guidelines
1. Inspect resource status and events
2. Check pod logs if applicable
3. Review recent configuration changes
4. Identify resource constraints or failures
5. Provide actionable recommendations

## Few-Shot Examples
{{range .Examples}}
### Example: {{.Title}}
**Scenario**: {{.Scenario}}
**Investigation Steps**:
{{.Steps}}
**Findings**: {{.Finding}}
**Recommendation**: {{.Recommendation}}
{{end}}

## Your Task
Investigate the incident described above and produce a detailed report.
```

**Example Library**:
Store few-shot examples in a configuration file:
```yaml
examples:
  - title: "CrashLoopBackOff due to missing ConfigMap"
    scenario: "Pod in CrashLoopBackOff, logs show missing environment variable."
    steps: |
      1. Checked pod events: Missing ConfigMap reference
      2. Verified ConfigMap existence in namespace
      3. Found ConfigMap name typo in Deployment spec
    finding: "Deployment references 'app-config' but ConfigMap is named 'app-configuration'"
    recommendation: "Update Deployment to reference correct ConfigMap name or rename ConfigMap"

  - title: "ImagePullBackOff due to authentication"
    scenario: "Pod cannot pull image from private registry."
    steps: |
      1. Checked pod events: ImagePullBackOff error
      2. Verified imagePullSecrets in pod spec
      3. Found missing Secret reference
    finding: "Pod missing imagePullSecrets for private registry"
    recommendation: "Add imagePullSecrets reference to ServiceAccount or pod spec"
```

**Rationale**:
- Few-shot examples significantly improve LLM performance on specialized tasks.
- Template approach allows easy customization per deployment without code changes.
- Examples demonstrate desired investigation methodology and output format.

**Best Practices**:
- Keep examples concise and relevant (3-5 examples max).
- Ensure consistent formatting across examples.
- Include diverse scenario types (resource issues, configuration errors, capacity problems).
- Update examples based on real investigation outcomes over time.

### Decision 5: Backend Selection Logic

**Decision**: Use explicit configuration with validation at startup.

**Selection Flow**:
1. Read `agent.backend` from configuration file.
2. Load backend-specific configuration from `agent.config.<backend>`.
3. Validate required environment variables and command availability.
4. Fail fast at startup if configuration is invalid (don't wait for first incident).
5. Log selected backend and configuration (with secrets redacted).

**Validation Requirements**:
- Verify command exists on PATH using `exec.LookPath()`.
- Check required environment variables are set.
- For OpenAI-compatible backends, validate API base URL format.
- Test backend with a "health check" prompt if possible during startup.

**Error Handling**:
- Configuration errors: Log and exit with non-zero status.
- Runtime invocation errors: Log error, mark incident as failed, send notification with error details.
- Partial backend failures: Continue processing other incidents (per-incident isolation).

## Risks / Trade-offs

### Risk: Slack Bot Token Management
**Risk**: Storing bot tokens securely and rotating them.
**Mitigation**:
- Support environment variable injection (`SLACK_BOT_TOKEN` from secrets).
- Document token rotation procedures.
- Use least-privilege scopes (`files:write`, `chat:write` only).

### Risk: Files.upload API Deprecation
**Risk**: Slack is deprecating legacy `files.upload` in November 2025.
**Mitigation**:
- Implement using the new pattern: `files.getUploadURLExternal` + `files.completeUploadExternal`.
- Monitor Slack's deprecation notices and update as needed.

### Risk: Agent Backend Compatibility
**Risk**: Different backends may have incompatible invocation patterns or capabilities.
**Mitigation**:
- Define clear interface contract for backends.
- Test each backend implementation separately.
- Document known limitations per backend.

### Risk: Few-Shot Example Staleness
**Risk**: Examples become outdated as system evolves.
**Mitigation**:
- Version example library alongside configuration.
- Include example update date in configuration.
- Periodically review examples against real incidents.

### Trade-off: Configuration Complexity
**Trade-off**: More flexible backends require more complex configuration.
**Mitigation**:
- Provide sensible defaults for common backends (Claude, Aider).
- Include example configurations in documentation.
- Validate configuration at startup with clear error messages.

### Trade-off: Rich Slack Messages vs Webhook Simplicity
**Trade-off**: Block Kit and file uploads require Bot Token, more setup overhead.
**Mitigation**:
- Make Bot Token optional - webhook-only remains supported.
- Provide clear migration guide.
- Include screenshots and examples in documentation.

## Migration Plan

### Phase 1: Add Bot Token Support (backward compatible)
1. Add `SLACK_BOT_TOKEN` environment variable support.
2. Implement `files.getUploadURLExternal` + `files.completeUploadExternal` flow.
3. If bot token present, use file upload; otherwise fall back to webhook.
4. No breaking changes - existing webhook-only deployments continue working.

### Phase 2: Add Block Kit Messages
1. Implement Block Kit message builder.
2. Use Block Kit when bot token is available.
3. Webhook notifications remain plain text (no Block Kit support).

### Phase 3: Add Agent Backend Abstraction
1. Refactor existing Claude invocation into `ClaudeBackend`.
2. Add configuration loading for `agent.backend` and `agent.config`.
3. Default to `claude` backend if not specified (backward compatible).

### Phase 4: Add Aider and OpenAI-Compatible Backends
1. Implement `AiderBackend` and `OpenAICompatibleBackend`.
2. Add configuration examples for each backend.
3. Document invocation patterns and limitations.

### Phase 5: Add Prompt Template System
1. Implement template engine for prompt generation.
2. Add default few-shot examples to configuration.
3. Allow custom example libraries via configuration file.

### Rollback Strategy
- Each phase is independently deployable.
- Configuration changes are non-breaking (additive only).
- If issues arise, remove new environment variables to fall back to previous behavior.
- Bot token issues: Remove `SLACK_BOT_TOKEN` to fall back to webhook.
- Backend issues: Set `agent.backend: "claude"` to use original implementation.

## Open Questions

1. **Block Kit Message Limits**: What is the maximum length for Block Kit messages? Should we truncate summaries?
   - Action: Research Slack's Block Kit limits and implement truncation if needed.

2. **File Upload Size Limits**: What is the maximum file size for Slack uploads?
   - Action: Document limits and implement file size checks before upload.

3. **Thread Reply Strategy**: Should follow-up artifacts always go in threads, or only when multiple artifacts exist?
   - Action: Default to threads for multiple artifacts, single message for single report.

4. **Backend Timeout Configuration**: Should each backend have different timeout values?
   - Action: Make timeout configurable per backend with sensible defaults.

5. **Example Selection Strategy**: Should examples be filtered based on incident type, or always show all examples?
   - Action: Start with showing all examples, add filtering in future iteration if needed.

6. **API Rate Limiting**: How should we handle Slack API rate limits for file uploads?
   - Action: Implement exponential backoff and retry logic with configurable max retries.
