# Design: State Persistence Migration

## Data Schema

The schema uses a denormalized approach to support efficient querying without joins. All critical incident metadata is replicated across tables to enable fast filtering and reporting.

### A. `fault_events`
Stores structured fault data received from the MCP server. Uses denormalization for query performance.
*   `fault_id` (PK): String. The upstream FaultID (hash) provided in the event.
*   `subscription_id`: String. MCP subscription identifier.
*   `cluster`: String. Source cluster (e.g., "prod-us-east-1"). **Indexed with CHECK constraint.**
*   `received_at`: Timestamp. When the event was received.
*   `resource_api_version`: String. Kubernetes resource API version.
*   `resource_kind`: String. Kubernetes resource kind. **Indexed.**
*   `resource_name`: String. Resource name.
*   `resource_namespace`: String. Resource namespace. **Indexed.**
*   `resource_uid`: String. Kubernetes UID.
*   `fault_type`: String. Type of fault detected. **Indexed with CHECK constraint.**
*   `severity`: String. Severity level (critical, high, medium, low). **Indexed.**
*   `context`: TEXT. Additional context as JSON string.
*   `timestamp`: Timestamp. When the fault occurred.

### B. `incidents`
Represents the lifecycle of a triage attempt. Uses denormalization to include all fault and resource data for efficient querying.
*   `incident_id` (PK): String (UUID).
*   `fault_id`: String. FK to `fault_events.fault_id`.
*   `status`: String (pending, investigating, resolved, failed, agent_failed). **Indexed with CHECK constraint.**
*   `created_at`: Timestamp. **Indexed for FIFO queries.**
*   `started_at`: Timestamp (Nullable). When agent execution began.
*   `completed_at`: Timestamp (Nullable). When incident was resolved/failed.
*   `exit_code`: Integer (Nullable). Agent process exit code.
*   `cluster`: String. Denormalized from fault_events. **Indexed.**
*   `subscription_id`: String. Denormalized from fault_events.
*   `resource_api_version`: String. Denormalized resource data.
*   `resource_kind`: String. Denormalized. **Indexed.**
*   `resource_name`: String. Denormalized.
*   `resource_namespace`: String. Denormalized. **Indexed.**
*   `resource_uid`: String. Denormalized.
*   `fault_type`: String. Denormalized. **Indexed.**
*   `severity`: String. Denormalized. **Indexed.**
*   `failure_reason`: TEXT (Nullable). Why the incident failed.
*   `context`: TEXT. Denormalized context.
*   `timestamp`: Timestamp. Denormalized fault timestamp.

### C. `agent_executions`
Tracks the specific run of the agent container.
*   `execution_id` (PK): String (UUID).
*   `incident_id`: String. FK to `incidents.incident_id`.
*   `started_at`: Timestamp.
*   `completed_at`: Timestamp (Nullable).
*   `exit_code`: Integer (Nullable).
*   `error_message`: TEXT. Agent error details.
*   `log_paths`: TEXT. Comma-separated log file paths.

### D. `triage_reports`
Stores the final investigation reports generated by agents.
*   `report_id` (PK): String (UUID).
*   `incident_id`: String. FK to `incidents.incident_id`.
*   `execution_id`: String. FK to `agent_executions.execution_id`.
*   `generated_at`: Timestamp.
*   `report_markdown`: TEXT. The investigation.md content.
*   `report_html`: TEXT (Nullable). HTML-rendered version of the report.

## Interface Definition

The `StateStore` interface provides methods for all state operations:

```go
type StateStore interface {
    // Create a new incident from a fault event
    CreateIncident(ctx context.Context, inc *incident.Incident, event *events.FaultEvent) error

    // Update incident status and optionally set started_at timestamp
    UpdateIncidentStatus(ctx context.Context, incidentID string, status string, startedAt *time.Time) error

    // Mark incident as complete with exit code and optional failure reason
    CompleteIncident(ctx context.Context, incidentID string, exitCode int, failureReason string) error

    // Record agent execution details
    RecordAgentExecution(ctx context.Context, exec *AgentExecution) error

    // Record triage report
    RecordTriageReport(ctx context.Context, report *TriageReport) error

    // Retrieve a single incident by ID
    GetIncident(ctx context.Context, incidentID string) (*incident.Incident, error)

    // List incidents with optional filtering
    ListIncidents(ctx context.Context, filters *IncidentFilters) ([]*incident.Incident, error)

    // Close database connection
    Close() error
}
```

## Integration Points

The StateStore is integrated into the event processing pipeline at five key points:

1. **CreateIncident** - Called immediately after receiving a fault event from MCP to persist the initial incident record with status `pending`.

2. **UpdateIncidentStatus** - Called before starting agent execution to update status to `investigating` and record the `started_at` timestamp.

3. **RecordAgentExecution** - Called after agent completion to record execution details including exit code, timing, error messages, and log paths.

4. **RecordTriageReport** - Called after successful investigation to persist the generated markdown and HTML reports.

5. **CompleteIncident** - Called after status finalization to update the incident's `completed_at` timestamp, final exit code, and any failure reason.

## Denormalization Strategy

To support efficient queries and filtering without complex joins, critical fields from `fault_events` are denormalized into the `incidents` table. This includes:
- Cluster information for multi-cluster filtering
- Resource metadata (kind, namespace, name) for resource-based queries
- Fault type and severity for incident classification
- Timestamps for temporal queries

This design prioritizes read performance and query simplicity over storage efficiency, which is acceptable given the expected data volumes.
