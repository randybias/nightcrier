# Design: Agent Runtime

## Context

The agent-runtime component is responsible for creating isolated workspaces and safely invoking AI agents (Claude Code in headless mode) to perform read-only triage of Kubernetes incidents. This component bridges the event processing layer with external AI tooling, ensuring security through workspace isolation, process lifecycle management, and read-only enforcement mechanisms.

### Background

Based on research into Claude Code CLI capabilities and Go subprocess management best practices:
- Claude Code supports headless mode via the `-p` flag with configurable output formats (`--output-format json` or `stream-json`)
- Tool permissions can be restricted via `--allowedTools` flag (e.g., `--allowedTools "Read,Grep,Glob"`)
- System prompts can be customized via `--append-system-prompt` or `--system-prompt-file`
- Skills are loaded from `.claude/skills/` directory structure with `SKILL.md` files
- The k8s-troubleshooter skill provides Kubernetes diagnostic capabilities
- Go's `exec.CommandContext` provides cancellation support, but child processes require explicit process group management
- Workspace isolation prevents cross-incident contamination and provides auditability

### Constraints

- Read-only operations only: agents must not modify cluster state
- Single concurrency per cluster: only one active agent investigation per cluster
- Internal environment: minimal prompt safety initially acceptable
- Go-based implementation consistent with kubernetes-mcp-server patterns
- Process management must handle timeouts, cancellations, and cleanup

### Stakeholders

- Ops on-call: needs fast, consistent triage reports
- SRE lead: wants auditability and control over agent behavior
- Agent maintainers: care about prompt patterns and skill loading
- Security observers: need to verify read-only enforcement

## Goals / Non-Goals

### Goals

- Create isolated workspace per incident with deterministic structure
- Invoke Claude Code CLI in headless mode with context and constraints
- Pass incident details, logs, and instructions via context bundle
- Load k8s-troubleshooter skill automatically for each agent session
- Restrict agent to read-only Kubernetes operations
- Capture agent output, artifacts, and exit codes
- Implement graceful process lifecycle with timeout and cancellation
- Clean up workspaces on completion or failure
- Provide observability into agent execution status

### Non-Goals

- Multiple concurrent agents per cluster (enforced upstream by event processor)
- Complex dedupe logic (handled by event processing layer)
- Agent output parsing or interpretation (handled by reporting layer)
- Custom skill development (use existing k8s-troubleshooter)
- Interactive agent sessions
- Agent result validation or correctness checking
- Distributed tracing of agent internal operations

## Decisions

### Decision 1: Workspace Layout Structure

**What:** Each incident gets a unique workspace directory with standardized structure:

```
/path/to/workspaces/
└── incident-{uuid}/
    ├── .claude/
    │   ├── commands/           # Custom slash commands (if needed)
    │   └── skills/
    │       └── k8s-troubleshooter/  # Symlink or copy from k8s4agents
    │           └── SKILL.md
    ├── context/
    │   ├── incident.json       # Structured incident metadata
    │   ├── event.json          # Raw event payload
    │   ├── logs.txt            # Enriched logs from kubernetes-mcp-server
    │   └── cluster-info.json   # Cluster context (name, namespace, resources)
    ├── output/
    │   ├── agent.log           # Agent stdout/stderr
    │   ├── artifacts/          # Files created by agent (if any)
    │   └── final-report.md     # Generated by reporting layer
    └── PROMPT.md               # The prompt passed to agent

```

**Why:**
- `.claude/` directory enables skill loading per Claude Code conventions
- `context/` directory provides all input data in structured formats
- `output/` directory captures all agent-generated content
- `PROMPT.md` makes the instruction visible for debugging
- Isolated per-incident prevents cross-contamination

**Alternatives Considered:**
- Flat structure: Rejected due to poor organization and harder cleanup
- Shared skills directory: Rejected due to potential version conflicts between concurrent agents
- Embedding context in prompt: Rejected due to token limits and lack of file-based tools usage

### Decision 2: Context Bundle Format

**What:** Context is provided as a combination of files and environment variables:

Files (in `context/` directory):
- `incident.json`: `{id, cluster, namespace, severity, timestamp, state}`
- `event.json`: Raw kubernetes-mcp-server event payload
- `logs.txt`: Multi-line log excerpts from affected pods
- `cluster-info.json`: `{clusterName, namespace, involvedResources[]}`

Environment variables:
- `INCIDENT_ID`: Unique incident identifier
- `INCIDENT_WORKSPACE`: Absolute path to workspace root
- `KUBERNETES_CLUSTER`: Cluster name
- `KUBERNETES_NAMESPACE`: Affected namespace
- `ANTHROPIC_API_KEY`: API key for Claude (or `CLAUDE_API_KEY`)
- `CLAUDE_READ_ONLY_MODE=true`: Custom marker for read-only enforcement

**Why:**
- Files provide rich, structured data that agents can read via tools
- Environment variables provide quick access to key metadata
- Separating concerns (structured data vs. logs) improves agent parsing
- `CLAUDE_READ_ONLY_MODE` serves as an extra guardrail and audit marker

**Alternatives Considered:**
- All-in-prompt: Rejected due to token limits and poor structure
- Database access: Rejected due to complexity and security concerns
- Streaming logs: Rejected for initial version; files provide simpler model

### Decision 3: Agent Invocation Mechanism

**What:** Use Go `exec.CommandContext` with the following command structure:

```bash
claude -p "$(cat PROMPT.md)" \
  --output-format stream-json \
  --allowedTools "Read,Grep,Glob,Bash(kubectl:get*,kubectl:describe*,kubectl:logs*)" \
  --append-system-prompt-file context/system-instructions.txt \
  --verbose
```

The process is managed with:
- Context with timeout (e.g., 10 minutes max per investigation)
- Process group management to ensure child process cleanup
- Graceful shutdown: SIGINT first, SIGKILL after WaitDelay
- Stdout/stderr captured to `output/agent.log`
- Exit code captured for status determination

**Why:**
- `exec.CommandContext` provides built-in timeout and cancellation
- `stream-json` output format enables progressive result consumption if needed
- `allowedTools` flag restricts agent capabilities (read-only kubectl patterns)
- Process groups prevent orphaned child processes
- Graceful shutdown allows agent cleanup (temporary files, etc.)

**Alternatives Considered:**
- Direct API/SDK integration: Rejected to avoid tight coupling and allow agent flexibility
- Shell script wrapper: Rejected due to poor error handling and process management
- No timeout: Rejected due to runaway process risk
- SIGKILL only: Rejected due to inability to perform cleanup

### Decision 4: Read-Only Enforcement Strategy

**What:** Multi-layered approach:

1. **Kubeconfig with read-only RBAC**
   - Provide kubeconfig with ServiceAccount limited to get/list/watch verbs
   - No create/update/delete/patch permissions

2. **Tool restriction via `--allowedTools`**
   - Only allow Read, Grep, Glob for file operations
   - Bash tool limited to read-only kubectl patterns: `kubectl:get*,kubectl:describe*,kubectl:logs*`
   - No Write, Edit, or unrestricted Bash access

3. **System prompt instruction**
   - Explicit instruction in `system-instructions.txt`: "You are in READ-ONLY triage mode. Do NOT attempt to modify cluster state, apply changes, or run remediation commands. Your role is ANALYSIS ONLY."

4. **Environment marker**
   - Set `CLAUDE_READ_ONLY_MODE=true` as a runtime marker
   - Can be checked by skills or custom scripts

5. **Workspace filesystem permissions**
   - Workspace directory writable (for agent artifacts)
   - No credentials or write-capable kubeconfigs present

**Why:**
- Defense in depth: multiple independent layers prevent accidental modifications
- RBAC enforcement at Kubernetes level provides strongest guarantee
- Tool restrictions prevent file system changes outside workspace
- System prompt guides agent behavior
- Combination provides auditability and security

**Alternatives Considered:**
- Prompt-only restriction: Rejected as insufficient; agents can still be confused
- Filesystem read-only workspace: Rejected as agent needs to create artifacts
- Network-level isolation: Rejected as overkill for internal environment and MVP

### Decision 5: Skill Loading Mechanism

**What:** Copy or symlink the k8s-troubleshooter skill into each workspace:

```bash
# During workspace setup
mkdir -p {workspace}/.claude/skills/
cp -r /path/to/k8s4agents/skills/k8s-troubleshooter \
      {workspace}/.claude/skills/k8s-troubleshooter
```

Claude Code will automatically discover and load skills from `.claude/skills/` directory.

**Why:**
- Claude Code conventions: skills in `.claude/skills/{skill-name}/SKILL.md`
- Per-workspace copy ensures isolation and version consistency
- No shared state between concurrent agents
- Skills can be updated between incidents without affecting running agents

**Alternatives Considered:**
- Shared global skills directory: Rejected due to potential version conflicts
- Skill path via environment variable: Not supported by Claude Code
- Inline skill in system prompt: Rejected due to token limits and poor organization
- Custom MCP server: Rejected as unnecessary complexity for MVP

### Decision 6: Process Lifecycle Management

**What:** Implement a state machine for agent process lifecycle:

```
CREATED → STARTING → RUNNING → [SUCCESS | FAILED | TIMEOUT | CANCELLED]
```

State transitions:
- `CREATED`: Workspace initialized, command prepared
- `STARTING`: Process spawned, waiting for initial output
- `RUNNING`: Agent actively processing (stdout/stderr flowing)
- `SUCCESS`: Exit code 0, output captured
- `FAILED`: Non-zero exit code or agent error
- `TIMEOUT`: Context deadline exceeded
- `CANCELLED`: Manual cancellation or circuit breaker trigger

Process management implementation:
```go
ctx, cancel := context.WithTimeout(parentCtx, maxDuration)
defer cancel()

cmd := exec.CommandContext(ctx, "claude", args...)
cmd.Dir = workspaceDir
cmd.Env = buildEnv()
cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true} // Process group

// Set up graceful shutdown
cmd.Cancel = func() error {
    return syscall.Kill(-cmd.Process.Pid, syscall.SIGINT) // Negative PID = process group
}
cmd.WaitDelay = 30 * time.Second // Wait before SIGKILL

// Capture output
stdout, stderr := setupOutputCapture()
cmd.Stdout = stdout
cmd.Stderr = stderr

// Execute
if err := cmd.Start(); err != nil { /* handle */ }
if err := cmd.Wait(); err != nil { /* handle */ }
```

**Why:**
- State machine provides clear lifecycle tracking
- Process groups ensure all child processes are terminated
- Graceful shutdown (SIGINT → SIGKILL) allows cleanup
- Output capture provides debugging and audit trail
- Context timeout prevents runaway processes

**Alternatives Considered:**
- Simple exec without state tracking: Rejected due to poor observability
- Kill only (no graceful shutdown): Rejected due to lost cleanup opportunity
- No process group management: Rejected due to orphaned subprocess risk
- No timeout: Rejected due to resource exhaustion risk

### Decision 7: Error Handling and Cleanup

**What:** Comprehensive error handling with guaranteed cleanup:

```go
func RunAgent(ctx context.Context, incident Incident) (result *AgentResult, err error) {
    workspace, err := createWorkspace(incident)
    if err != nil {
        return nil, fmt.Errorf("workspace creation: %w", err)
    }

    // Ensure cleanup on all exit paths
    defer func() {
        if cleanupErr := cleanupWorkspace(workspace, result, err); cleanupErr != nil {
            // Log cleanup error but don't override original error
            log.Error("cleanup failed", "workspace", workspace, "error", cleanupErr)
        }
    }()

    // Setup, execute, capture
    if err := setupContext(workspace, incident); err != nil {
        return nil, fmt.Errorf("context setup: %w", err)
    }

    result, err = executeAgent(ctx, workspace)
    return result, err
}
```

Cleanup policy:
- On success: Keep workspace for reporting layer to consume
- On failure: Keep workspace for debugging (mark as failed)
- On timeout/cancellation: Keep workspace with partial results
- Explicit cleanup via separate GC process or retention policy

**Why:**
- `defer` ensures cleanup runs on all exit paths
- Preserving workspaces enables debugging and audit
- Separate GC process allows configurable retention
- Error wrapping provides clear error chain

**Alternatives Considered:**
- Immediate cleanup on error: Rejected due to loss of debugging information
- No cleanup: Rejected due to disk space concerns
- Synchronous cleanup in main flow: Rejected due to delay in error reporting

### Decision 8: Observability and Metrics

**What:** Emit metrics and structured logs at key lifecycle points:

Metrics:
- `agent_runtime_invocations_total{cluster, status}`: Total agent invocations
- `agent_runtime_duration_seconds{cluster, status}`: Agent execution duration
- `agent_runtime_workspace_size_bytes{cluster}`: Workspace disk usage
- `agent_runtime_active_agents{cluster}`: Currently active agents
- `agent_runtime_errors_total{cluster, error_type}`: Error counts

Structured logs (JSON):
```json
{
  "timestamp": "2025-12-17T20:00:00Z",
  "level": "info",
  "component": "agent-runtime",
  "incident_id": "incident-uuid",
  "cluster": "prod-cluster",
  "event": "agent_started",
  "workspace": "/workspaces/incident-uuid",
  "command": "claude -p ...",
  "pid": 12345
}
```

**Why:**
- Metrics enable monitoring and alerting on agent health
- Structured logs provide audit trail and debugging capability
- Per-cluster metrics support multi-cluster deployments
- Duration metrics help tune timeout values

**Alternatives Considered:**
- Text logs only: Rejected due to poor queryability
- No metrics: Rejected due to lack of operational visibility
- Distributed tracing: Deferred as overkill for MVP

## Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     Event Processing Layer                   │
│                  (triggers agent-runtime)                    │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                      AgentRuntime                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  WorkspaceManager                                     │  │
│  │  - CreateWorkspace(incident) → workspaceDir           │  │
│  │  - SetupSkills(workspaceDir)                          │  │
│  │  - CleanupWorkspace(workspaceDir, policy)             │  │
│  └──────────────────────────────────────────────────────┘  │
│                             │                                │
│                             ▼                                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  ContextBuilder                                       │  │
│  │  - BuildContextBundle(incident) → files + env        │  │
│  │  - WriteContextFiles(workspaceDir, incident)          │  │
│  │  - BuildSystemPrompt(incident) → instructions.txt     │  │
│  └──────────────────────────────────────────────────────┘  │
│                             │                                │
│                             ▼                                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  AgentExecutor                                        │  │
│  │  - BuildCommand(workspace) → exec.Cmd                 │  │
│  │  - ConfigureProcessGroup(cmd)                         │  │
│  │  - SetupOutputCapture(cmd) → stdout/stderr writers    │  │
│  │  - Execute(ctx, cmd) → result + error                │  │
│  │  - MonitorLifecycle(cmd) → state transitions         │  │
│  └──────────────────────────────────────────────────────┘  │
│                             │                                │
│                             ▼                                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  ArtifactCollector                                    │  │
│  │  - CollectOutput(workspaceDir) → artifacts           │  │
│  │  - CaptureExitCode(cmd) → status                     │  │
│  │  - PackageResults(workspace) → result bundle         │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                     Reporting Layer                          │
│            (consumes workspace and generates report)         │
└─────────────────────────────────────────────────────────────┘
```

## Sequence Diagram

```
EventProcessor    AgentRuntime    WorkspaceMgr    ContextBuilder    AgentExecutor    Claude CLI
     │                  │               │                │                │              │
     │─ StartAgent() ──>│               │                │                │              │
     │                  │               │                │                │              │
     │                  │─CreateWorkspace(incident)─────>│                │              │
     │                  │<─────── workspaceDir ──────────│                │              │
     │                  │               │                │                │              │
     │                  │───SetupSkills(workspaceDir)───>│                │              │
     │                  │<──────────── done ─────────────│                │              │
     │                  │               │                │                │              │
     │                  │─BuildContextBundle(incident)──>│                │              │
     │                  │               │                │                │              │
     │                  │               │─ WriteContextFiles()            │              │
     │                  │               │─ BuildSystemPrompt()            │              │
     │                  │               │─ BuildEnvVars()                 │              │
     │                  │<─── contextBundle ─────────────│                │              │
     │                  │               │                │                │              │
     │                  │─Execute(ctx, workspace, context)───────────────>│              │
     │                  │               │                │                │              │
     │                  │               │                │                │─ exec.CommandContext()─>│
     │                  │               │                │                │              │
     │                  │               │                │                │              │─ Load .claude/skills/
     │                  │               │                │                │              │─ Read context files
     │                  │               │                │                │              │─ Execute triage
     │                  │               │                │                │              │─ Write artifacts
     │                  │               │                │                │              │
     │                  │               │                │                │<─ exit(0) ───│
     │                  │               │                │                │              │
     │                  │<────── AgentResult ────────────────────────────│              │
     │                  │               │                │                │              │
     │<─ AgentResult ───│               │                │                │              │
     │                  │               │                │                │              │
```

## API Interfaces

### Core Interface

```go
// AgentRuntime is the main interface for invoking agents
type AgentRuntime interface {
    // RunAgent creates a workspace and invokes the agent for the given incident
    RunAgent(ctx context.Context, incident *Incident) (*AgentResult, error)

    // GetStatus returns the current status of an agent invocation
    GetStatus(incidentID string) (*AgentStatus, error)

    // Cancel attempts to gracefully cancel a running agent
    Cancel(incidentID string) error
}

// Incident represents a Kubernetes incident requiring triage
type Incident struct {
    ID          string
    Cluster     string
    Namespace   string
    Severity    string
    Timestamp   time.Time
    EventData   json.RawMessage  // Raw kubernetes-mcp-server event
    Logs        []string         // Enriched log lines
    Resources   []Resource       // Involved K8s resources
}

// AgentResult contains the outcome of an agent invocation
type AgentResult struct {
    IncidentID    string
    Status        AgentStatus
    WorkspaceDir  string
    StartTime     time.Time
    EndTime       time.Time
    ExitCode      int
    OutputLog     string           // Path to agent.log
    Artifacts     []string         // Paths to generated files
    Error         error
}

// AgentStatus represents the agent lifecycle state
type AgentStatus string

const (
    StatusCreated   AgentStatus = "created"
    StatusStarting  AgentStatus = "starting"
    StatusRunning   AgentStatus = "running"
    StatusSuccess   AgentStatus = "success"
    StatusFailed    AgentStatus = "failed"
    StatusTimeout   AgentStatus = "timeout"
    StatusCancelled AgentStatus = "cancelled"
)
```

### Component Interfaces

```go
// WorkspaceManager handles workspace creation and cleanup
type WorkspaceManager interface {
    CreateWorkspace(incident *Incident) (string, error)
    SetupSkills(workspaceDir string) error
    CleanupWorkspace(workspaceDir string, policy CleanupPolicy) error
}

// ContextBuilder constructs the context bundle for the agent
type ContextBuilder interface {
    BuildContextBundle(incident *Incident) (*ContextBundle, error)
    WriteContextFiles(workspaceDir string, bundle *ContextBundle) error
}

// ContextBundle contains all context data for the agent
type ContextBundle struct {
    Files       map[string][]byte  // filename -> content
    EnvVars     map[string]string  // env var name -> value
    SystemPrompt string
    UserPrompt   string
}

// AgentExecutor handles process execution and lifecycle
type AgentExecutor interface {
    Execute(ctx context.Context, config *ExecutionConfig) (*AgentResult, error)
    Monitor(incidentID string) (*AgentStatus, error)
}

// ExecutionConfig contains all parameters for agent execution
type ExecutionConfig struct {
    WorkspaceDir string
    ContextBundle *ContextBundle
    Timeout      time.Duration
    Command      string
    Args         []string
}
```

## Configuration

Agent runtime behavior is configured via environment variables and config file:

```yaml
# config.yaml
agent_runtime:
  # Agent command configuration
  agent_command: "claude"  # or "codex", "goose", etc.

  # Workspace configuration
  workspace_root: "/var/lib/event-runner/workspaces"
  workspace_retention_hours: 72  # Keep workspaces for 3 days

  # Execution limits
  max_duration_minutes: 10
  graceful_shutdown_seconds: 30

  # Skill configuration
  skills_source: "/opt/k8s4agents/skills"
  skills:
    - name: "k8s-troubleshooter"
      enabled: true

  # Security configuration
  read_only_mode: true
  allowed_tools:
    - "Read"
    - "Grep"
    - "Glob"
    - "Bash(kubectl:get*,kubectl:describe*,kubectl:logs*)"

  # Kubeconfig with read-only RBAC
  kubeconfig_path: "/etc/event-runner/kubeconfig-readonly.yaml"

  # Observability
  metrics_enabled: true
  structured_logging: true
  log_level: "info"
```

Environment variables (overrides):
- `AGENT_RUNTIME_COMMAND`: Agent CLI command
- `AGENT_RUNTIME_WORKSPACE_ROOT`: Workspace root directory
- `AGENT_RUNTIME_MAX_DURATION`: Max agent runtime (e.g., "10m")
- `AGENT_RUNTIME_SKILLS_SOURCE`: Path to skills directory
- `AGENT_RUNTIME_KUBECONFIG`: Path to read-only kubeconfig
- `ANTHROPIC_API_KEY`: Claude API key
- `AGENT_RUNTIME_READ_ONLY=true`: Enforce read-only mode

## Risks / Trade-offs

### Risk: Agent Escaping Read-Only Restrictions
**Impact:** Agent could potentially modify cluster state despite restrictions

**Mitigation:**
- RBAC enforcement at Kubernetes level (strongest guarantee)
- Tool restrictions via `--allowedTools` flag
- System prompt instructions
- Audit logs of all agent actions
- Regular review of agent behavior

**Trade-off:** Multi-layered restrictions add complexity but provide defense in depth

### Risk: Orphaned Child Processes
**Impact:** Process leaks could consume resources over time

**Mitigation:**
- Process group management with negative PID signals
- Context timeout enforcement
- Graceful shutdown with SIGINT → SIGKILL
- Monitoring of process counts
- Container restart policies (if deployed in K8s)

**Trade-off:** Graceful shutdown adds latency but prevents cleanup issues

### Risk: Workspace Disk Usage
**Impact:** Long-running deployment could fill disk with old workspaces

**Mitigation:**
- Configurable retention policy (default 72 hours)
- Separate GC process for cleanup
- Disk usage metrics and alerting
- Workspace size limits per incident
- Log rotation for agent output

**Trade-off:** Longer retention helps debugging but increases storage needs

### Risk: Agent Invocation Failures
**Impact:** Claude CLI might fail due to auth, network, or API issues

**Mitigation:**
- Comprehensive error handling with clear error types
- Retry logic for transient failures (upstream in event processor)
- Fallback to minimal report on failure
- Detailed logging of command and environment
- Health checks on CLI availability

**Trade-off:** Retry logic adds complexity but improves reliability

### Risk: Skill Version Skew
**Impact:** Different workspaces might use different skill versions

**Mitigation:**
- Copy skills into each workspace (not symlink)
- Version tracking in workspace metadata
- Centralized skill source with versioning
- Validation that required skills are present

**Trade-off:** Per-workspace copying uses more disk but ensures consistency

### Risk: Sensitive Data Exposure
**Impact:** Logs or events might contain secrets, tokens, or PII

**Mitigation:**
- Log sanitization before writing to workspace
- Restricted workspace permissions (owner-only read/write)
- Workspaces stored in protected directory
- Audit of workspace access
- Retention policies limit exposure window

**Trade-off:** Sanitization might remove useful debugging information

## Migration Plan

N/A - This is a new component with no existing implementation to migrate from.

Initial rollout plan:
1. Phase 1: Implement core workspace and execution logic
2. Phase 2: Add skill loading and context bundle creation
3. Phase 3: Integrate with event processing layer
4. Phase 4: Add observability and monitoring
5. Phase 5: Tune timeouts and cleanup policies based on production data

## Open Questions

### Q1: Should we support multiple agent backends (Claude, Codex, etc.)?
**Status:** Deferred to post-MVP

**Considerations:**
- Different CLIs have different flags and conventions
- Would require abstraction layer for command building
- Context bundle format might need to be agent-agnostic
- Skills might not be portable across agents

**Recommendation:** Start with Claude Code only, design interface to be extensible

### Q2: How should we handle agent crashes vs. agent-reported errors?
**Status:** Needs decision before implementation

**Options:**
1. Treat all non-zero exits as failures (simple but loses nuance)
2. Parse exit codes: 0=success, 1=agent error, 2=crash, etc.
3. Parse JSON output for agent-reported status
4. Use combination of exit code + output parsing

**Recommendation:** Option 2 (exit codes) for MVP, enhance with output parsing later

### Q3: Should we implement progressive output streaming?
**Status:** Deferred to post-MVP

**Considerations:**
- `stream-json` output format enables real-time updates
- Could provide progress visibility to ops teams
- Adds complexity to output handling
- Requires websocket or SSE for delivery to UI

**Recommendation:** Capture full output for MVP, add streaming in Phase 5

### Q4: How should we handle skill updates during runtime?
**Status:** Needs decision before implementation

**Options:**
1. Fixed skills at agent-runtime startup (simple but inflexible)
2. Check for skill updates before each invocation (could cause inconsistency)
3. Version skills and allow configuration per deployment
4. Separate skill management service

**Recommendation:** Option 1 for MVP, revisit with operational experience

### Q5: Should workspaces be ephemeral or persistent?
**Status:** Decided - persistent with retention policy

**Rationale:**
- Persistence enables debugging and audit
- Retention policy prevents disk exhaustion
- Separate GC process allows flexible policies
- Ops teams need access to results after completion

### Q6: How do we prevent workspace path traversal attacks?
**Status:** Needs implementation guidance

**Mitigations:**
- Validate incident ID format (UUID only)
- Use `filepath.Join` and `filepath.Clean` for path construction
- Verify workspace is under workspace_root before operations
- Restrict agent write access to workspace only

**Recommendation:** Implement path validation utility functions in WorkspaceManager
