package sqlite

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"sync"
	"testing"
	"time"

	"github.com/rbias/nightcrier/internal/events"
	"github.com/rbias/nightcrier/internal/incident"
	"github.com/rbias/nightcrier/internal/storage"
)

// setupTestStore creates a new in-memory SQLite store for testing.
func setupTestStore(t *testing.T) *Store {
	t.Helper()

	cfg := &Config{
		Path:            ":memory:",
		BusyTimeout:     5 * time.Second,
		MaxOpenConns:    10,
		MaxIdleConns:    2,
		ConnMaxLifetime: time.Hour,
	}

	store, err := New(cfg)
	if err != nil {
		t.Fatalf("failed to create test store: %v", err)
	}

	// Run migrations
	if err := runTestMigrations(store.db); err != nil {
		t.Fatalf("failed to run migrations: %v", err)
	}

	return store
}

// runTestMigrations applies the schema to the test database.
func runTestMigrations(db *sql.DB) error {
	schema := `
-- fault_events table stores the raw fault events received from kubernetes-mcp-server
CREATE TABLE IF NOT EXISTS fault_events (
    fault_id TEXT PRIMARY KEY,
    subscription_id TEXT NOT NULL,
    cluster TEXT NOT NULL,
    received_at TIMESTAMP NOT NULL,
    resource_api_version TEXT,
    resource_kind TEXT,
    resource_name TEXT,
    resource_namespace TEXT,
    resource_uid TEXT,
    fault_type TEXT NOT NULL,
    severity TEXT NOT NULL,
    context TEXT NOT NULL,
    timestamp TEXT NOT NULL,
    CONSTRAINT idx_fault_events_cluster CHECK (cluster <> ''),
    CONSTRAINT idx_fault_events_fault_type CHECK (fault_type <> '')
);

CREATE INDEX IF NOT EXISTS idx_fault_events_cluster ON fault_events(cluster);
CREATE INDEX IF NOT EXISTS idx_fault_events_received_at ON fault_events(received_at);
CREATE INDEX IF NOT EXISTS idx_fault_events_fault_type ON fault_events(fault_type);
CREATE INDEX IF NOT EXISTS idx_fault_events_severity ON fault_events(severity);

-- incidents table stores the investigation incidents created from fault events
CREATE TABLE IF NOT EXISTS incidents (
    incident_id TEXT PRIMARY KEY,
    fault_id TEXT NOT NULL,
    triggering_event_id TEXT,
    status TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    exit_code INTEGER,
    failure_reason TEXT,
    cluster TEXT NOT NULL,
    namespace TEXT,
    fault_type TEXT NOT NULL,
    severity TEXT NOT NULL,
    context TEXT NOT NULL,
    timestamp TEXT NOT NULL,
    resource_api_version TEXT,
    resource_kind TEXT,
    resource_name TEXT,
    resource_namespace TEXT,
    resource_uid TEXT,
    FOREIGN KEY (fault_id) REFERENCES fault_events(fault_id),
    CONSTRAINT chk_incidents_status CHECK (status IN ('pending', 'investigating', 'resolved', 'failed', 'agent_failed')),
    CONSTRAINT chk_incidents_cluster CHECK (cluster <> ''),
    CONSTRAINT chk_incidents_fault_type CHECK (fault_type <> '')
);

CREATE INDEX IF NOT EXISTS idx_incidents_fault_id ON incidents(fault_id);
CREATE INDEX IF NOT EXISTS idx_incidents_status ON incidents(status);
CREATE INDEX IF NOT EXISTS idx_incidents_cluster ON incidents(cluster);
CREATE INDEX IF NOT EXISTS idx_incidents_created_at ON incidents(created_at);
CREATE INDEX IF NOT EXISTS idx_incidents_namespace ON incidents(namespace);
CREATE INDEX IF NOT EXISTS idx_incidents_fault_type ON incidents(fault_type);
CREATE INDEX IF NOT EXISTS idx_incidents_severity ON incidents(severity);

-- agent_executions table stores details of agent execution attempts
CREATE TABLE IF NOT EXISTS agent_executions (
    execution_id TEXT PRIMARY KEY,
    incident_id TEXT NOT NULL,
    started_at TIMESTAMP NOT NULL,
    completed_at TIMESTAMP,
    exit_code INTEGER,
    error_message TEXT,
    log_paths TEXT,
    FOREIGN KEY (incident_id) REFERENCES incidents(incident_id),
    CONSTRAINT chk_agent_executions_incident_id CHECK (incident_id <> '')
);

CREATE INDEX IF NOT EXISTS idx_agent_executions_incident_id ON agent_executions(incident_id);
CREATE INDEX IF NOT EXISTS idx_agent_executions_started_at ON agent_executions(started_at);

-- triage_reports table stores the investigation reports generated by agents
CREATE TABLE IF NOT EXISTS triage_reports (
    report_id TEXT PRIMARY KEY,
    incident_id TEXT NOT NULL,
    execution_id TEXT NOT NULL,
    generated_at TIMESTAMP NOT NULL,
    report_markdown TEXT NOT NULL,
    report_html TEXT,
    FOREIGN KEY (incident_id) REFERENCES incidents(incident_id),
    FOREIGN KEY (execution_id) REFERENCES agent_executions(execution_id),
    CONSTRAINT chk_triage_reports_incident_id CHECK (incident_id <> ''),
    CONSTRAINT chk_triage_reports_execution_id CHECK (execution_id <> '')
);

CREATE INDEX IF NOT EXISTS idx_triage_reports_incident_id ON triage_reports(incident_id);
CREATE INDEX IF NOT EXISTS idx_triage_reports_execution_id ON triage_reports(execution_id);
CREATE INDEX IF NOT EXISTS idx_triage_reports_generated_at ON triage_reports(generated_at);
`
	_, err := db.Exec(schema)
	return err
}

// createTestEvent creates a test fault event.
func createTestEvent(faultID string) *events.FaultEvent {
	return &events.FaultEvent{
		FaultID:        faultID,
		SubscriptionID: "sub-123",
		Cluster:        "test-cluster",
		ReceivedAt:     time.Now(),
		Resource: &events.ResourceInfo{
			APIVersion: "v1",
			Kind:       "Pod",
			Name:       "test-pod",
			Namespace:  "default",
			UID:        "pod-uid-123",
		},
		FaultType: "PodCrashLoop",
		Severity:  "critical",
		Context:   "Pod is crash looping",
		Timestamp: time.Now().Format(time.RFC3339),
	}
}

// createTestIncident creates a test incident from an event.
func createTestIncident(incidentID string, event *events.FaultEvent) *incident.Incident {
	return incident.NewFromEvent(incidentID, event)
}

func TestNew(t *testing.T) {
	tests := []struct {
		name    string
		cfg     *Config
		wantErr bool
	}{
		{
			name: "default config",
			cfg:  DefaultConfig(),
		},
		{
			name: "in-memory database",
			cfg: &Config{
				Path:            ":memory:",
				BusyTimeout:     5 * time.Second,
				MaxOpenConns:    10,
				MaxIdleConns:    2,
				ConnMaxLifetime: time.Hour,
			},
		},
		{
			name: "nil config uses defaults",
			cfg:  nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			store, err := New(tt.cfg)
			if (err != nil) != tt.wantErr {
				t.Errorf("New() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if store != nil {
				defer store.Close()
			}
		})
	}
}

func TestCreateIncident(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-001")
	inc := createTestIncident("inc-001", event)

	// Create incident
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	// Verify incident was created
	retrieved, err := store.GetIncident(ctx, inc.IncidentID)
	if err != nil {
		t.Fatalf("GetIncident() error = %v", err)
	}
	if retrieved == nil {
		t.Fatal("GetIncident() returned nil")
	}

	// Verify fields
	if retrieved.IncidentID != inc.IncidentID {
		t.Errorf("IncidentID = %v, want %v", retrieved.IncidentID, inc.IncidentID)
	}
	if retrieved.FaultID != inc.FaultID {
		t.Errorf("FaultID = %v, want %v", retrieved.FaultID, inc.FaultID)
	}
	if retrieved.Status != inc.Status {
		t.Errorf("Status = %v, want %v", retrieved.Status, inc.Status)
	}
	if retrieved.Cluster != inc.Cluster {
		t.Errorf("Cluster = %v, want %v", retrieved.Cluster, inc.Cluster)
	}
	if retrieved.Resource == nil {
		t.Fatal("Resource is nil")
	}
	if retrieved.Resource.Kind != "Pod" {
		t.Errorf("Resource.Kind = %v, want Pod", retrieved.Resource.Kind)
	}
}

func TestCreateIncident_Duplicate(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-002")
	inc := createTestIncident("inc-002", event)

	// Create incident first time
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() first call error = %v", err)
	}

	// Try to create same incident again - should fail
	err = store.CreateIncident(ctx, inc, event)
	if err == nil {
		t.Fatal("CreateIncident() second call should have failed")
	}
}

func TestUpdateIncidentStatus(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-003")
	inc := createTestIncident("inc-003", event)

	// Create incident
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	// Update status
	startedAt := time.Now()
	err = store.UpdateIncidentStatus(ctx, inc.IncidentID, incident.StatusResolved, &startedAt)
	if err != nil {
		t.Fatalf("UpdateIncidentStatus() error = %v", err)
	}

	// Verify update
	retrieved, err := store.GetIncident(ctx, inc.IncidentID)
	if err != nil {
		t.Fatalf("GetIncident() error = %v", err)
	}
	if retrieved.Status != incident.StatusResolved {
		t.Errorf("Status = %v, want %v", retrieved.Status, incident.StatusResolved)
	}
	if retrieved.StartedAt == nil {
		t.Fatal("StartedAt is nil")
	}
}

func TestUpdateIncidentStatus_NotFound(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	startedAt := time.Now()

	// Try to update non-existent incident
	err := store.UpdateIncidentStatus(ctx, "nonexistent", incident.StatusResolved, &startedAt)
	if err == nil {
		t.Fatal("UpdateIncidentStatus() should have failed for non-existent incident")
	}
}

func TestCompleteIncident(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-004")
	inc := createTestIncident("inc-004", event)

	// Create incident
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	tests := []struct {
		name          string
		exitCode      int
		failureReason string
		wantStatus    string
	}{
		{
			name:       "successful completion",
			exitCode:   0,
			wantStatus: incident.StatusResolved,
		},
		{
			name:          "failed completion",
			exitCode:      1,
			failureReason: "agent failed",
			wantStatus:    incident.StatusFailed,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a new incident for each test case
			testEvent := createTestEvent("fault-" + tt.name)
			testInc := createTestIncident("inc-"+tt.name, testEvent)
			err := store.CreateIncident(ctx, testInc, testEvent)
			if err != nil {
				t.Fatalf("CreateIncident() error = %v", err)
			}

			// Complete incident
			err = store.CompleteIncident(ctx, testInc.IncidentID, tt.exitCode, tt.failureReason)
			if err != nil {
				t.Fatalf("CompleteIncident() error = %v", err)
			}

			// Verify completion
			retrieved, err := store.GetIncident(ctx, testInc.IncidentID)
			if err != nil {
				t.Fatalf("GetIncident() error = %v", err)
			}
			if retrieved.Status != tt.wantStatus {
				t.Errorf("Status = %v, want %v", retrieved.Status, tt.wantStatus)
			}
			if retrieved.ExitCode == nil {
				t.Fatal("ExitCode is nil")
			}
			if *retrieved.ExitCode != tt.exitCode {
				t.Errorf("ExitCode = %v, want %v", *retrieved.ExitCode, tt.exitCode)
			}
			if retrieved.CompletedAt == nil {
				t.Fatal("CompletedAt is nil")
			}
			if tt.failureReason != "" && retrieved.FailureReason != tt.failureReason {
				t.Errorf("FailureReason = %v, want %v", retrieved.FailureReason, tt.failureReason)
			}
		})
	}
}

func TestRecordAgentExecution(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-005")
	inc := createTestIncident("inc-005", event)

	// Create incident first
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	// Record execution
	exec := &storage.AgentExecution{
		ExecutionID: "exec-001",
		IncidentID:  inc.IncidentID,
		StartedAt:   time.Now(),
		LogPaths: map[string]string{
			"stdout": "/path/to/stdout.log",
			"stderr": "/path/to/stderr.log",
		},
	}

	err = store.RecordAgentExecution(ctx, exec)
	if err != nil {
		t.Fatalf("RecordAgentExecution() error = %v", err)
	}

	// Verify execution was recorded
	var retrievedExecID string
	var logPathsJSON []byte
	err = store.db.QueryRowContext(ctx, "SELECT execution_id, log_paths FROM agent_executions WHERE execution_id = ?", exec.ExecutionID).
		Scan(&retrievedExecID, &logPathsJSON)
	if err != nil {
		t.Fatalf("Failed to retrieve execution: %v", err)
	}
	if retrievedExecID != exec.ExecutionID {
		t.Errorf("ExecutionID = %v, want %v", retrievedExecID, exec.ExecutionID)
	}

	// Verify log paths JSON
	var logPaths map[string]string
	err = json.Unmarshal(logPathsJSON, &logPaths)
	if err != nil {
		t.Fatalf("Failed to unmarshal log paths: %v", err)
	}
	if logPaths["stdout"] != "/path/to/stdout.log" {
		t.Errorf("stdout log path = %v, want /path/to/stdout.log", logPaths["stdout"])
	}
}

func TestRecordAgentExecution_Update(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-006")
	inc := createTestIncident("inc-006", event)

	// Create incident first
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	// Record execution start
	exec := &storage.AgentExecution{
		ExecutionID: "exec-002",
		IncidentID:  inc.IncidentID,
		StartedAt:   time.Now(),
	}

	err = store.RecordAgentExecution(ctx, exec)
	if err != nil {
		t.Fatalf("RecordAgentExecution() start error = %v", err)
	}

	// Update execution with completion info
	completedAt := time.Now()
	exitCode := 0
	exec.CompletedAt = &completedAt
	exec.ExitCode = &exitCode

	err = store.RecordAgentExecution(ctx, exec)
	if err != nil {
		t.Fatalf("RecordAgentExecution() update error = %v", err)
	}

	// Verify update
	var retrievedExitCode sql.NullInt64
	err = store.db.QueryRowContext(ctx, "SELECT exit_code FROM agent_executions WHERE execution_id = ?", exec.ExecutionID).
		Scan(&retrievedExitCode)
	if err != nil {
		t.Fatalf("Failed to retrieve execution: %v", err)
	}
	if !retrievedExitCode.Valid || retrievedExitCode.Int64 != 0 {
		t.Errorf("ExitCode = %v, want 0", retrievedExitCode.Int64)
	}
}

func TestRecordTriageReport(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	event := createTestEvent("fault-007")
	inc := createTestIncident("inc-007", event)

	// Create incident and execution
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	exec := &storage.AgentExecution{
		ExecutionID: "exec-003",
		IncidentID:  inc.IncidentID,
		StartedAt:   time.Now(),
	}
	err = store.RecordAgentExecution(ctx, exec)
	if err != nil {
		t.Fatalf("RecordAgentExecution() error = %v", err)
	}

	// Record triage report
	report := &storage.TriageReport{
		ReportID:       "report-001",
		IncidentID:     inc.IncidentID,
		ExecutionID:    exec.ExecutionID,
		GeneratedAt:    time.Now(),
		ReportMarkdown: "# Investigation Report\n\nDetails here...",
		ReportHTML:     "<h1>Investigation Report</h1><p>Details here...</p>",
	}

	err = store.RecordTriageReport(ctx, report)
	if err != nil {
		t.Fatalf("RecordTriageReport() error = %v", err)
	}

	// Verify report was recorded
	var retrievedReportID string
	var markdown string
	err = store.db.QueryRowContext(ctx, "SELECT report_id, report_markdown FROM triage_reports WHERE report_id = ?", report.ReportID).
		Scan(&retrievedReportID, &markdown)
	if err != nil {
		t.Fatalf("Failed to retrieve report: %v", err)
	}
	if retrievedReportID != report.ReportID {
		t.Errorf("ReportID = %v, want %v", retrievedReportID, report.ReportID)
	}
	if markdown != report.ReportMarkdown {
		t.Errorf("ReportMarkdown = %v, want %v", markdown, report.ReportMarkdown)
	}
}

func TestGetIncident_NotFound(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()

	// Try to get non-existent incident
	retrieved, err := store.GetIncident(ctx, "nonexistent")
	if err != nil {
		t.Fatalf("GetIncident() error = %v", err)
	}
	if retrieved != nil {
		t.Error("GetIncident() should return nil for non-existent incident")
	}
}

func TestListIncidents(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()

	// Create multiple incidents
	for i := 0; i < 5; i++ {
		event := createTestEvent(fmt.Sprintf("fault-%03d", i))
		inc := createTestIncident(fmt.Sprintf("inc-%03d", i), event)
		if i < 3 {
			inc.Status = incident.StatusResolved
		} else {
			inc.Status = incident.StatusInvestigating
		}
		err := store.CreateIncident(ctx, inc, event)
		if err != nil {
			t.Fatalf("CreateIncident() error = %v", err)
		}
	}

	tests := []struct {
		name    string
		filters *storage.IncidentFilters
		want    int
	}{
		{
			name:    "list all",
			filters: nil,
			want:    5,
		},
		{
			name: "filter by status",
			filters: &storage.IncidentFilters{
				Status: []string{incident.StatusResolved},
			},
			want: 3,
		},
		{
			name: "filter by cluster",
			filters: &storage.IncidentFilters{
				Cluster: "test-cluster",
			},
			want: 5,
		},
		{
			name: "limit results",
			filters: &storage.IncidentFilters{
				Limit: 2,
			},
			want: 2,
		},
		{
			name: "pagination",
			filters: &storage.IncidentFilters{
				Limit:  2,
				Offset: 2,
			},
			want: 2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			incidents, err := store.ListIncidents(ctx, tt.filters)
			if err != nil {
				t.Fatalf("ListIncidents() error = %v", err)
			}
			if len(incidents) != tt.want {
				t.Errorf("ListIncidents() returned %d incidents, want %d", len(incidents), tt.want)
			}
		})
	}
}

func TestListIncidents_TimeRange(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()

	now := time.Now()
	yesterday := now.Add(-24 * time.Hour)
	tomorrow := now.Add(24 * time.Hour)

	// Create incidents
	event := createTestEvent("fault-time")
	inc := createTestIncident("inc-time", event)
	err := store.CreateIncident(ctx, inc, event)
	if err != nil {
		t.Fatalf("CreateIncident() error = %v", err)
	}

	tests := []struct {
		name    string
		filters *storage.IncidentFilters
		want    int
	}{
		{
			name: "created after yesterday",
			filters: &storage.IncidentFilters{
				CreatedAfter: &yesterday,
			},
			want: 1,
		},
		{
			name: "created before tomorrow",
			filters: &storage.IncidentFilters{
				CreatedBefore: &tomorrow,
			},
			want: 1,
		},
		{
			name: "created after tomorrow",
			filters: &storage.IncidentFilters{
				CreatedAfter: &tomorrow,
			},
			want: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			incidents, err := store.ListIncidents(ctx, tt.filters)
			if err != nil {
				t.Fatalf("ListIncidents() error = %v", err)
			}
			if len(incidents) != tt.want {
				t.Errorf("ListIncidents() returned %d incidents, want %d", len(incidents), tt.want)
			}
		})
	}
}

func TestConcurrentAccess(t *testing.T) {
	store := setupTestStore(t)
	defer store.Close()

	ctx := context.Background()
	numGoroutines := 10
	var wg sync.WaitGroup

	// Concurrent writes
	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			event := createTestEvent(fmt.Sprintf("fault-concurrent-%d", id))
			inc := createTestIncident(fmt.Sprintf("inc-concurrent-%d", id), event)
			err := store.CreateIncident(ctx, inc, event)
			if err != nil {
				t.Errorf("CreateIncident() error = %v", err)
			}
		}(i)
	}

	wg.Wait()

	// Verify all incidents were created
	incidents, err := store.ListIncidents(ctx, nil)
	if err != nil {
		t.Fatalf("ListIncidents() error = %v", err)
	}
	if len(incidents) != numGoroutines {
		t.Errorf("ListIncidents() returned %d incidents, want %d", len(incidents), numGoroutines)
	}
}

func TestClose(t *testing.T) {
	store := setupTestStore(t)

	err := store.Close()
	if err != nil {
		t.Errorf("Close() error = %v", err)
	}

	// Verify database is closed by trying to use it
	ctx := context.Background()
	_, err = store.GetIncident(ctx, "test")
	if err == nil {
		t.Error("GetIncident() should fail after Close()")
	}
}
